package com.liyafeng;


import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;

/**
 * Created by liyafeng on 16/11/2017.
 * 这里主要是问答形式的算法题，
 * 如果是写代码形式的算法题，见com.liyafeng.algorithm
 */

public class Algorithm {


    public static void main(String[] args) {

        ReferenceQueue<Integer> queue = new ReferenceQueue<>();
        SoftReference<Integer> softReference = new SoftReference<>(1);
        WeakReference<Integer> weakReference = new WeakReference<>(2);
        PhantomReference<Integer> phantomReference = new PhantomReference<>(3, queue);

        int i = 0;
        while (true) {
            Integer integer = softReference.get();
            if (integer != null) {
                System.out.println("soft:" + integer);
            } else {
                System.out.println("soft gc");
            }
            Integer integer1 = weakReference.get();
            if (integer1 != null) {
                System.out.println("weak:" + integer1);
            } else {
                System.out.println("weak gc");
            }

            Integer integer2 = phantomReference.get();
            if (integer2 != null) {
                System.out.println("phantom:" + integer2);
            } else {
                System.out.println("phantom gc" + queue.poll());
            }
            System.out.println("==================");
//            i++;
            new java.lang.String("123" + "123" + "123");
            Runtime.getRuntime().gc();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }


    }
    //region 排序

    /**
     * 几种排序比较？
     */
    void a1() {
        /*
         * 查看 res/drawable/sort_all.jpg
         *
         * 具体实现查看 com.liyafeng.algorithm.basic.sort包下的类
         *
         * https://zhuanlan.zhihu.com/p/34421623(视频比较)
         *
         *
         * */
    }

    /**
     * 快速排序 quick 的原理？
     * ==========
     * 快速排序，思想是切分（partition），取第一个元素k，两个指针，i ,j 指向第二个元素和尾元素
     * i找到第一个比k大的，j找到第一个比k小的，交换，直到j < i ，最后交换k 和 j
     * <p>
     * 如此反复
     * ==========
     * 改进，在小数组中改用插入排序，小数组插入排序比快速排序要快，因为快排的递归需要调用自己
     */
    void a1_1() {

    }


    /**
     * 插入排序 insertion 和希尔排序 shell 区别？
     * ======
     * 区别：
     * 希尔排序是改进版的插入排序
     * 插入排序每次选取剩余数组的第一个元素，插入到排序好的数组中，但是如果数组很大
     * 假如最后一个元素是最小的，那么他将要和左边排序好的所有元素比较后才能移动到最左边
     * 希尔排序则可以将数组大体排序好（h有序的），这样最后一次完全的插入排序时
     * 数组中元素的比较次数减少了。
     * <p>
     * 时间复杂度insertion O(n^2) shell大约为O(n^3/2)
     * ==============
     * 希尔原理：
     * h取值范围 3h+1...1 (3h+1<n) n为数组的长度
     * <p>
     * h   遍历顺序h/3...13 ,4 ,1
     * <p>
     * 从第h个元素开始遍历剩下所以的元素，每隔h个数字组成一个数组进行插入排序
     * <p>
     * 当前的j和前j-h（j>h）的数字比较，小的插入前面
     * <p>
     * <p>
     * <p>
     * ===============
     * 插入排序是从剩余数组中选第一个元素，插入前面到已经排序好的数组中
     * <p>
     * <p>
     * ============
     * insertion会比selection比较次数要少一些
     */
    void a1_2() {

    }

    /**
     * 选择排序selection 和 冒泡排序bubble 区别？插入排序的区别？
     * 选择排序， 插入排序的区别？
     */
    void a1_3() {

        /*
         *
         * ====选择排序selection 和 冒泡排序bubble 区别？插入排序的区别？
         * 选择排序是每次遍历剩余数组，找出最小的元素放在剩余数组的最前面
         *
         * 冒泡排序是每次剩余数组中的元素两两比较，最小的元素会冒到剩余数组的最前面
         * <p>
         * 两者时间复杂度都是O(n^2)，
         * 但是selection要比bubble快一些，因为选择排序的交换次数少
         * 冒泡排序每次都要比较一下
         *
         * ==========选择排序  插入排序的区别？================
         * 选择排序是找出剩余数组中最小的，与剩余数组的第一个元素交换
         * 而插入排序是，选择剩余数组的第一个元素，插入到前面有序数组中（依次比较）
         * <p>
         * 他们复杂度都是O(n^2)，
         * 实际中插入排序要比选择排序快，因为选择排序每次都要遍历剩下的数组（找出最小的）
         * 而插入排序只有在数组是逆序的情况下才需要每次插入都比较，
         *
         * =======================================
         * 冒泡排序是最慢的，比较次数多，交换次数也多
         * 随机情况下
         * 插入排序 > 选择排序 > 冒泡排序
         *
         *
         * */
    }


    /**
     * 归并排序 merge
     * =========
     * 分治思想的应用
     * 两个有序的小数组合并为一个有序的大数组
     * 优点是只需要O(NlogN)时间复杂度，缺点是需要一个辅助空间，和N成正比
     * <p>
     * ===================
     * 重点是归并方法merge
     * a[] lo mid hi
     * lo - mid  mid -hi 的两段都是有序的
     * <p>
     * =================
     * 改进，可以对小数组排序的时候改为插入排序，这样比纯归并快10%
     */
    void a1_4() {

    }

    //endregion


    //region 查找

    /**
     * 几种查找算法比较？
     * ===========
     * 二分法，红黑树，散列表（拉链法，线性探测法）
     *
     * 1. 线性查找：
     * - 时间复杂度：平均情况和最坏情况下为O(n)。
     * - 空间复杂度：O(1)。
     * - 算法简单，适用于小型数据集。
     *
     * 2. 二分查找：
     * - 时间复杂度：O(logn)。
     * - 空间复杂度：O(1)。
     * - 适用于有序数组，效率高。
     *
     * 3. 哈希查找：
     * - 时间复杂度：平均情况下为O(1)，最坏情况下为O(n)。
     * - 空间复杂度：取决于哈希表的大小。
     * - 适用于大型数据集，具有快速查找的特点。
     *
     * 4. 二叉查找树（BST）：
     * - 时间复杂度：平均情况下为O(logn)，最坏情况下为O(n)。
     * - 空间复杂度：O(n)。
     * - 适用于动态数据集，支持动态插入和删除。
     *
     * 5. 平衡二叉查找树（AVL树、红黑树等）：
     * - 时间复杂度：平均情况下为O(logn)。
     * - 空间复杂度：O(n)。
     * - 适用于动态数据集，支持动态插入和删除，并且保持树的平衡。
     *
     * 这些查找算法在不同的应用场景下具有不同的特点和适用性，可以根据具体的需求选择合适的查找算法。
     *
     *
     */
    void a2() {

    }
    //endregion

    //region 字符串

    /**
     * 了解字符串操作？
     * ==============
     * 字符串匹配，字符串排序（低位优先的字符串排序，高位优先），（单词查找树）
     */
    void a3() {

    }
    //endregion

    //region 图


    /**
     * 什么是图？
     */
    public void a4() {
        /*
         * 定义：由一组定点和一组能够将两个顶点相连的边组成
         */
    }

    /**
     * 图的算法？
     * ===========
     * 最短路径，最小生成树，拓扑排序
     */
    public void a4_1() {

    }

    //endregion

    //region 树

    /**
     * 什么是树？
     */
    public void a5_1() {
        /*
         *  树(Tree)是n(n≥0)个结点的有限集T，T为空时称为空树，否则它满足如下两个条件：
         *   有且仅有一个特定的称为根(Root)的结点；
         *   其余的结点可分为m(m≥0)个互不相交的子集Tl，T2，…，Tm，其中每个子集本身又是一棵树，并称其为根的子树(Subree)。
         *
         *
         */
    }

    /**
     * 说说几种常用的树
     *
     * ====二叉搜索树（Binary Search Tree，BST）
     * 是一种二叉树，其中每个节点的值都大于其左子树中的任意节点的值，且小于其右子树中的任意节点的值
     * 。这种特性使得二叉搜索树具有以下特点：
     *
     * 1. 快速查找：由于二叉搜索树的特性，可以通过比较节点的值来快速定位需要查找的元素。
     *
     * 2. 插入和删除：在二叉搜索树中插入和删除元素也相对容易，只需按照节点值的大小关系进行调整即可。
     *
     * 3. 中序遍历：对二叉搜索树进行中序遍历可以得到有序的元素序列。
     *
     * 尽管二叉搜索树具有上述优点，但在某些情况下，由于树的不平衡性，可能会导致树的高度过高，
     * 从而影响其性能。为了解决这个问题，衍生出了平衡二叉搜索树（如 AVL 树和红黑树）等数据结构，
     * 以保持树的平衡性。
     *
     * ====和rbtree（红黑树）效率的比较？
     * 去看算法 第四版
     *
     * 红黑树是一种自平衡的二叉搜索树，它通过引入颜色标记和一些特定的规则来保持树的平衡。红黑树的实现主要依赖于以下几个规则：
     *
     * 1. 节点颜色：每个节点都被标记为红色或黑色。
     *
     * 2. 根节点和叶子节点：根节点是黑色的，叶子节点（NIL 节点）也是黑色的。
     *
     * 3. 红色节点规则：红色节点的子节点不能是红色的，即红色节点不能相连。
     *
     * 4. 黑色节点规则：从任一节点到其每个叶子节点的路径上，黑色节点的数量必须相同。
     *
     * 通过这些规则，红黑树能够保持相对平衡，从而保证了树的高度不会过高，使得查找、插入和删除等操作的时间复杂度能够保持在较低的水平。
     *
     * 在实现红黑树时，需要对插入和删除操作进行特殊处理，以保证树的平衡性。例如，插入操作可能会导致树的不平衡，需要通过旋转和颜色调整来恢复平衡。删除操作也需要进行类似的调整来保持树的平衡。
     *
     * 总的来说，红黑树通过引入颜色标记和特定的规则，以及对插入和删除操作的特殊处理，实现了一种高效的自平衡二叉搜索树。
     *
     * ===什么AVL树？
     * AVL树是一种自平衡的二叉搜索树，它通过维护每个节点的平衡因子（即左子树的高度减去右子树的高度）来保持树的平衡。AVL树的特点包括：
     *
     * 1. 平衡因子：每个节点的平衡因子必须为 -1、0 或 1。如果平衡因子的绝对值大于 1，则需要通过旋转操作来恢复平衡。
     *
     * 2. 自平衡：在进行插入或删除操作后，AVL树会通过旋转操作来保持树的平衡。
     *
     * 3. 高度平衡：由于AVL树的平衡因子限制，使得树的高度相对较低，从而保证了查找、插入和删除等操作的时间复杂度较低。
     *
     * 4. 实现复杂度：由于需要维护平衡因子，并且在插入和删除操作时可能需要进行多次旋转，因此AVL树的实现相对复杂。
     *
     * 总的来说，AVL树通过维护平衡因子和进行旋转操作来保持树的平衡，从而实现了一种高效的自平衡二叉搜索树。
     *
     *
     * ==========区别：AVL树和红黑树是两种常见的自平衡二叉搜索树，它们在实现和性能方面有以下几点区别：
     *
     * 1. 平衡因子 vs. 节点颜色：
     * - AVL树通过维护每个节点的平衡因子（即左子树的高度减去右子树的高度）来保持树的平衡。
     * - 红黑树通过引入节点的颜色标记和一些特定的规则来保持树的平衡。
     *
     * 2. 调整操作：
     * - 在插入或删除节点后，AVL树可能需要进行多次旋转操作来恢复平衡。
     * - 红黑树在插入或删除节点后，通过旋转和颜色调整来保持树的平衡。
     *
     * 3. 实现复杂度：
     * - 由于AVL树需要维护平衡因子，并且在插入和删除操作时可能需要进行多次旋转，因此其实现相对复杂。
     * - 红黑树的实现相对简单，因为它只需要维护节点的颜色和遵循一些特定的规则。
     *
     * 4. 性能差异：
     * - 在查找操作上，AVL树由于严格的平衡性，通常比红黑树的性能略好。
     * - 在插入和删除操作上，红黑树由于旋转和颜色调整的特性，通常比AVL树的性能略好。
     *
     * 总的来说，AVL树和红黑树都是高效的自平衡二叉搜索树，它们在实现和性能上有一些区别，可以根据具体应用场景选择合适的数据结构。
     *
     * ======堆
     * 堆是一种特殊的树形数据结构，通常用于实现优先队列。堆分为大根堆和小根堆两种类型：
     *
     * 1. 大根堆：
     * - 在大根堆中，每个节点的值都大于或等于其子节点的值。
     * - 大根堆的根节点是整个堆中的最大值。
     *
     * 2. 小根堆：
     * - 在小根堆中，每个节点的值都小于或等于其子节点的值。
     * - 小根堆的根节点是整个堆中的最小值。
     *
     * 堆通常是一个完全二叉树，可以使用数组来表示。在堆中，父节点和子节点之间的值满足一定的大小关系，从而保证了根节点是整个堆中的最大值或最小值。
     *
     * 堆的主要应用包括实现优先队列、堆排序、以及在图算法中的一些应用（如 Dijkstra 算法和 Prim 算法）等。
     * 由于其特殊的性质，堆能够高效地支持插入、删除和获取最大/最小值等操作。
     *
     *
     *
     */
    public void a5_2() {
        /*
         * 见res/drawable/tree.png
         */
    }




    /**
     * 什么是B树？什么是B+树？有什么区别？
     * ----------------------
     * （B树等于 B-树） B-Tree
     * http://blog.csdn.net/v_JULY_v/article/details/6530142
     *
     * B树和B+树都是一种多路搜索树，常用于数据库和文件系统中，用于组织和管理大量数据。它们的主要区别在于以下几点：
     *
     * 1. B树：
     * - B树是一种自平衡的多路搜索树，每个节点可以包含多个子节点。
     * - 在B树中，每个节点既存储数据，又存储子节点的指针。
     * - B树的叶子节点包含了整个数据集，而非仅包含键值。
     * - B树的节点分裂和合并操作会导致树的高度发生变化。
     *
     * 2. B+树：
     * - B+树也是一种自平衡的多路搜索树，每个节点同样可以包含多个子节点。
     * - 在B+树中，数据只存储在叶子节点，非叶子节点只存储键值和子节点的指针。
     * - B+树的叶子节点通过指针连接成一个有序链表，便于范围查询和遍历。
     * - B+树的节点分裂和合并操作不会导致树的高度发生变化。
     *
     * 主要区别在于B+树的叶子节点只存储数据，非叶子节点只存储键值和子节点的指针，
     * 并且叶子节点通过指针连接成有序链表。
     * 这些特性使得B+树在范围查询和遍历时具有更好的性能，同时也更适合用于数据库和文件系统中的索引结构。
     *
     * ======= 完全二叉树 满二叉树 平衡二叉树
     *
     * - 完全二叉树（Complete Binary Tree）：是一种二叉树，除了最后一层外，每一层的节点都是满的，并且最后一层的节点都依次排列在左边。换句话说，最后一层的节点从左到右依次填满，缺失的位置只能出现在最后一层的右侧。完全二叉树常用于堆数据结构的实现。
     *
     * - 满二叉树（Full Binary Tree）：是一种特殊的二叉树，每个节点要么没有子节点，要么有两个子节点。换句话说，每个节点要么是叶子节点，要么有两个子节点。满二叉树的叶子节点都在同一层。
     *
     * - 平衡二叉树（Balanced Binary Tree）：是一种二叉树，它的左右子树的高度差不超过 1。换句话说，对于平衡二叉树中的每个节点，它的左子树和右子树的高度差都不超过 1。平衡二叉树的设计旨在保持树的高度较低，以便在进行搜索、插入和删除等操作时能够保持较好的性能。
     *
     * 这些概念是在二叉树的基础上进行的特殊定义，用于描述不同类型的二叉树结构。
     *
     *
     *
     * ====叶子节点
     * 叶子节点是树数据结构中的末端节点，也就是没有子节点的节点。在树的结构中，叶子节点是位于树的最底层的节点，
     * 它们不再有子节点，因此也被称为终端节点。在B树和B+树中，叶子节点存储实际的数据，而非叶子节点则存储键值和子节点的指针。
     *
     *
     */
    public void a5_3() {
        /*
         * 二叉查找树，平衡二叉查找树，红黑树，都是二叉的结构，也就是说只能有两个子节点
         * 我们知道查找效率和树的深度有关，如果是大量数据，采用二叉树的结构，那么深度会很深
         * 每访问一次节点就是一次磁盘IO读写（因为我们数据量很大，所以数据都是存储在磁盘中
         * 而不能讲他们加载到内存中）
         *   所以就有了多叉树。
         * B树，是Balance树的简称，意为多路平衡查找树.一棵m阶的B 树，意思就是子节点最多有m个
         * 我们先要理解磁盘的结构，和计算机如何查找到磁盘上的数据并读取的。
         * 磁盘查找要依次查找 柱面好，盘面好，磁道号，其中最花费时间的就是读写臂
         * 移动到指定的柱面，所以我们树越深，读取的节点越多，那么IO耗费的时间越多1
         * 所以我们试图在一个节点中存储多个数据，来减少树的高度。这样来节省
         * IO时间。所以B树更适合磁盘查找。
         * =================B+Tree=================
         * B树的实际值都存在各个结点中，而B+树的实际值都存在叶子结点中
         * 而非叶子结点中存的都是他指向的叶子结点的最小值。
         * 结构见drawable/Btree.jpg ，
         * ----------------优点---------------------
         * B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引
         * 1.占用内存更少，因为查找所加载的结点中没有实际值，所以占用内存更少
         * 2.B树虽然提高了磁盘的IO性能，但没有解决遍历元素效率低下的问题
         *    而B+树所有数据都在叶子结点，所以我们把叶子结点串联形成一个链表，
         *    可以更高效的遍历。
         * B树只能中序遍历树。
         * 比如数据库经常用到范围查找，我们可以找到min，和max，然后遍历叶子结点
         * 形成的链表即可。这是B+树的优点。
         *
         *==========================B*树==============================
         * B*树是在B+树的基础上，对非根和非叶子节点添加了指向兄弟节点的指针
         * 这样做是为了当自己节点分配满的时候，可以将数据分配给未满的兄弟节点
         * 这样就不用想B+树一样要分裂成两个节点了，
         * 所以B*树的优势在于分裂新节点的概率低了，这样空间使用率高了
         *
         */
    }


    /**

     */
    public void a5_4() {
        /*
         * https://www.zhihu.com/question/19856999
         * AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，
         * 他们在1962年的论文《An algorithm for the organization of information》中发表了它
         * AVL是自平衡二叉查找树
         *
         *
         *
         * */
    }



    //endregion



    //region 压缩/加密

    /**
     * 数据编码（压缩）？
     */
    void a6() {

    }
    //endregion
}
